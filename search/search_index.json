{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geodepoly Docs","text":"<ul> <li>API: <code>solve_poly</code>, <code>solve_all</code>, <code>solve_one</code></li> <li>Methods: <code>hybrid</code>, <code>aberth</code>, <code>dk</code>, <code>numpy</code></li> <li>Resummation: <code>None</code>, <code>pade</code>, <code>borel</code>, <code>borel-pade</code></li> <li>CAS: SymPy plugin, JSON CLI for Mathematica/Maple</li> </ul> <p>See the README for quickstart and <code>paper/GeodePoly_MVP.md</code> for a draft paper.</p>"},{"location":"#theory-and-paper-mapping","title":"Theory and Paper Mapping","text":"<ul> <li>See <code>docs/paper_guide.md</code> for how the paper \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d maps to the implementation.</li> <li>The module <code>geodepoly.hyper_catalan</code> provides utilities for the multivariate series <code>S[t2,t3,...]</code> described in the paper.</li> </ul>"},{"location":"#benchmarks-plots","title":"Benchmarks &amp; Plots","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"#cas-examples","title":"CAS Examples","text":"<ul> <li>SymPy comparison: <code>python examples/sympy_vs_nroots.py</code></li> <li>JSON bridge round-trip: <code>python examples/json_bridge_roundtrip.py</code></li> <li>Mathematica: <code>RunProcess[{\"python\",\"bridges/geodepoly_cli.py\"}, \"StandardInput\"-&gt;payloadJSON]</code></li> <li>Maple: <code>ssystem(\"python bridges/geodepoly_cli.py\", payloadJSON)</code></li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#core-solvers","title":"Core solvers","text":"<ul> <li><code>geodepoly.solve_all(coeffs: List[complex], method: str = \"hybrid\", max_order: int = 24, boots: int = 2, tol: float = 1e-12, resum: Optional[str] = None, refine_steps: int = 3, verbose: bool = False) -&gt; List[complex]</code></li> <li>Methods: <code>\"hybrid\" | \"aberth\" | \"dk\" | \"numpy\"</code></li> <li>Resummation: <code>None | \"pade\" | \"borel\" | \"borel-pade\" | \"auto\"</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import solve_all\ncoeffs = [1, 0, -7, 6]  # 1 - 7 x^2 + 6 x^3 = 0 (low-&gt;high)\nroots = solve_all(coeffs, method=\"hybrid\", resum=\"auto\")\n</code></pre> <ul> <li> <p><code>geodepoly.solve_one(coeffs: List[complex], center: complex|None=None, max_order: int=24, boots: int=3, tol: float=1e-14, resum: Optional[str]=None, refine_steps: int=2) -&gt; complex</code></p> </li> <li> <p><code>geodepoly.solve_poly = solve_all</code> (convenience alias)</p> </li> </ul>"},{"location":"api/#series-reversion-paper-aligned","title":"Series reversion (paper-aligned)","text":"<ul> <li><code>geodepoly.series_solve_all(coeffs, max_order=24, boots=3, tol=1e-12, max_deflation=None, verbose=False) -&gt; List[complex]</code></li> <li><code>geodepoly.series_one_root(coeffs, center=None, max_order=24, boots=3, tol=1e-14) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import series_one_root\ncoeffs = [1, -1.2, 0.3, 1.0]\nroot = series_one_root(coeffs, center=0.0, max_order=24, boots=2)\n</code></pre>"},{"location":"api/#sympy-integration","title":"SymPy integration","text":"<ul> <li><code>geodepoly.sympy_plugin.sympy_solve(poly, return_: str = \"numeric\", **kwargs) -&gt; List</code></li> <li><code>poly</code>: <code>sympy.Expr</code> or <code>sympy.Poly</code></li> <li><code>return_</code>: <code>\"numeric\"</code> (Python complex) or <code>\"expr\"</code> (SymPy numbers)</li> </ul> <p>Example</p> <pre><code>import sympy as sp\nfrom geodepoly.sympy_plugin import sympy_solve\n\nx = sp.symbols('x')\nroots = sympy_solve(x**5 + x - 1, method=\"hybrid\", resum=\"auto\", return_=\"numeric\")\n</code></pre>"},{"location":"api/#eigenvalues","title":"Eigenvalues","text":"<ul> <li><code>geodepoly.eigs.solve_eigs(A) -&gt; List[complex]</code></li> <li>Forms characteristic polynomial via Faddeev\u2013LeVerrier and calls <code>solve_all</code>.</li> </ul> <p>Example</p> <pre><code>import numpy as np\nfrom geodepoly.eigs import solve_eigs\n\nA = np.array([[0,1],[ -6, 7 ]], dtype=complex)\neigvals = solve_eigs(A)\n</code></pre>"},{"location":"api/#hyper-catalan-utilities","title":"Hyper-Catalan utilities","text":"<ul> <li><code>geodepoly.hyper_catalan.hyper_catalan_coefficient(m_counts: Dict[int,int]) -&gt; int</code></li> <li><code>geodepoly.hyper_catalan.evaluate_hyper_catalan(t_values: Dict[int,complex], max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.evaluate_quadratic_slice(t2: complex, max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.catalan_number(n: int) -&gt; int</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import evaluate_hyper_catalan, evaluate_quadratic_slice, catalan_number\n\nt2 = 0.05\nalpha = evaluate_quadratic_slice(t2, max_weight=20)\nc3 = catalan_number(3)\n</code></pre>"},{"location":"api/#resummation-helpers","title":"Resummation helpers","text":"<ul> <li><code>geodepoly.resummation.eval_series_plain(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_auto(g: List[complex], t: complex) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly.resummation import eval_series_plain, eval_series_pade, eval_series_borel_pade, eval_series_auto\ng = [1, 1, 1, 1, 1]  # toy coefficients for demo\nt = 0.9\nvals = dict(plain=eval_series_plain(g,t), pade=eval_series_pade(g,t), borel_pade=eval_series_borel_pade(g,t), auto=eval_series_auto(g,t))\n</code></pre>"},{"location":"api/#cli-bridge-json","title":"CLI bridge (JSON)","text":"<ul> <li><code>bridges/geodepoly_cli.py</code></li> <li>stdin: <code>{ \"coeffs\": [...], \"kwargs\": { ... } }</code></li> <li>stdout: <code>{ \"roots\": [[re, im], ...] }</code></li> </ul> <p>Example</p> <pre><code>python bridges/geodepoly_cli.py &lt;&lt;'JSON'\n{\"coeffs\":[-6,11,-6,1],\"kwargs\":{\"method\":\"hybrid\",\"resum\":\"auto\"}}\nJSON\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#solve-all-roots-hybrid","title":"Solve all roots (hybrid)","text":"<pre><code>from geodepoly import solve_all\ncoeffs = [1, 0, -7, 6]\nroots = solve_all(coeffs, method=\"hybrid\", resum=\"auto\")\n</code></pre>"},{"location":"examples/#series-one-root","title":"Series one root","text":"<pre><code>from geodepoly import series_one_root\ncoeffs = [1, -1.2, 0.3, 1.0]\nroot = series_one_root(coeffs, center=0.0, max_order=24, boots=2)\n</code></pre>"},{"location":"examples/#sympy-integration","title":"SymPy integration","text":"<pre><code>import sympy as sp\nfrom geodepoly.sympy_plugin import sympy_solve\nx = sp.symbols('x')\nroots = sympy_solve(x**5 + x - 1, method=\"hybrid\", resum=\"auto\", return_=\"numeric\")\n</code></pre>"},{"location":"examples/#eigenvalues","title":"Eigenvalues","text":"<pre><code>import numpy as np\nfrom geodepoly.eigs import solve_eigs\nA = np.array([[0,1],[-6,7]], dtype=complex)\nvals = solve_eigs(A)\n</code></pre>"},{"location":"examples/#json-bridge","title":"JSON bridge","text":"<pre><code>python bridges/geodepoly_cli.py &lt;&lt;'JSON'\n{\"coeffs\":[-6,11,-6,1],\"kwargs\":{\"method\":\"hybrid\",\"resum\":\"auto\"}}\nJSON\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-coefficient-order-do-functions-expect","title":"What coefficient order do functions expect?","text":"<p>Low-to-high (a0, a1, ..., aN) for polynomial a0 + a1 x + ... + aN x^N = 0.</p>"},{"location":"faq/#how-do-i-choose-a-method","title":"How do I choose a method?","text":"<ul> <li><code>hybrid</code> is a good default (series seeds + Aberth finisher).</li> <li><code>aberth</code> for simultaneous refinement.</li> <li><code>dk</code> for robust derivative-free finishing.</li> <li><code>numpy</code> if you prefer companion eigenvalues (requires NumPy).</li> </ul>"},{"location":"faq/#when-should-i-use-resummation","title":"When should I use resummation?","text":"<p>If the local parameter |t| = |-a0/a1| is not small, use <code>resum=\"auto\"</code> (tries Pad\u00e9/Borel\u2013Pad\u00e9).</p>"},{"location":"faq/#what-about-multiple-or-clustered-roots","title":"What about multiple or clustered roots?","text":"<p>They are ill-conditioned. We add adaptive damping in Aberth and multiplicity-aware Halley polish, but residuals may still be sensitive.</p>"},{"location":"faq/#does-sympy-need-to-be-installed","title":"Does SymPy need to be installed?","text":"<p>Only for the <code>sympy_plugin</code>. Core solvers work with Python complex numbers.</p>"},{"location":"faq/#are-eigenvalues-supported","title":"Are eigenvalues supported?","text":"<p>Yes, via <code>solve_eigs(A)</code> (Faddeev\u2013LeVerrier + solver polish).</p>"},{"location":"gallery/","title":"Gallery","text":""},{"location":"gallery/#bench-plots","title":"Bench plots","text":""},{"location":"gallery/#examples","title":"Examples","text":"<ul> <li>Methods comparison: see <code>examples/compare_methods.py</code></li> <li>Resummation effect: see <code>examples/resummation_effect.py</code></li> <li>Eigenvalues demo: see <code>examples/eigs_demo.py</code></li> </ul>"},{"location":"geode_gpu_spec/","title":"Geode GPU Roadmap (draft)","text":""},{"location":"geode_gpu_spec/#goals","title":"Goals","text":"<ul> <li>Batched root solves for many polynomials</li> <li>Stable kernels for Aberth/Halley updates</li> </ul>"},{"location":"geode_gpu_spec/#tiling-layout","title":"Tiling &amp; Layout","text":"<ul> <li>Face-layer tiling aligned with hyper-Catalan layers</li> <li>Structure-of-arrays layout for complex ops</li> </ul>"},{"location":"geode_gpu_spec/#prototype","title":"Prototype","text":"<ul> <li>JAX/NumPy sketch for vectorized series seeds and Aberth steps</li> </ul>"},{"location":"geode_gpu_spec/#next-steps","title":"Next steps","text":"<ul> <li>Microbenchmarks and accuracy checks vs CPU</li> <li>Memory-bound vs compute-bound analysis</li> </ul>"},{"location":"how_it_works/","title":"How it works (deep-dive)","text":"<p>This section summarizes the core algorithmic choices behind geodepoly and connects them to the paper.</p>"},{"location":"how_it_works/#1-recenter-and-series-seed","title":"1) Recenter and series seed","text":"<p>Given coefficients low-to-high <code>p(x) = a0 + a1 x + ... + aN x^N</code>, choose a center <code>\u03bc</code> and expand <code>q(y) = p(\u03bc + y) = a0 + a1 y + a2 y^2 + ...</code> via binomial shifting. If <code>a1 \u2260 0</code>, set <code>t = -a0/a1</code>.</p> <p>We invert <code>F(y) = y + \u03b22 y^2 + \u03b23 y^3 + ...</code> with <code>\u03b2k = ak/a1</code> using Lagrange inversion to obtain inverse-series coefficients <code>{g_m}</code> for the local root increment <code>y \u2248 \u03a3 g_m t^m</code>.</p>"},{"location":"how_it_works/#2-resummation-and-auto-selection","title":"2) Resummation and auto selection","text":"<p>Truncated series can be fragile near their convergence boundary (|t| ~ 1). We provide: - Plain: direct Horner evaluation of \u03a3 g_m t^m - Pad\u00e9: near-diagonal Pad\u00e9 rational approximation - Borel\u2013Pad\u00e9: Pade of the Borel transform followed by Gauss\u2013Laguerre - Auto: small Pad\u00e9 grid scored for stability, falling back to Borel\u2013Pad\u00e9 or plain</p> <p>Use <code>resum=\"auto\"</code> for robust default behavior.</p>"},{"location":"how_it_works/#3-bootstrap-and-deflation","title":"3) Bootstrap and deflation","text":"<p>A few bootstrap steps update the center <code>\u03bc \u2190 \u03bc + y</code>. When a root is good, synthetic division (deflation) reduces degree. The MVP solves all roots with a robust finisher after obtaining one or two good seeds.</p>"},{"location":"how_it_works/#4-finishers-and-polishing","title":"4) Finishers and polishing","text":"<ul> <li>Aberth\u2013Ehrlich: simultaneous iteration with adaptive damping and minimal repulsion for clustered roots</li> <li>Durand\u2013Kerner: derivative-free simultaneous method</li> <li>Halley polishing: applied per root; we also provide multiplicity-aware Halley when a root appears repeated</li> </ul>"},{"location":"how_it_works/#5-multipleclustered-roots","title":"5) Multiple/clustered roots","text":"<p>We estimate local multiplicity using <code>m\u0302 \u2248 Re( p * p'' / p'^2 )</code> and apply a multiplicity-aware Halley update when <code>m\u0302 \u2265 2</code>. Clustered roots benefit from Aberth damping and repulsion.</p>"},{"location":"how_it_works/#6-hyper-catalan-connection","title":"6) Hyper-Catalan connection","text":"<p>The generating series <code>S[t2,t3,...]</code> with hyper-Catalan coefficients solves a canonical geometric polynomial and motivates the series-reversion view. We expose utilities to evaluate slices of <code>S</code> and to compute coefficients for exploration and benchmarks.</p>"},{"location":"how_it_works/#7-eigenvalues-via-characteristic-polynomial","title":"7) Eigenvalues via characteristic polynomial","text":"<p>For small/medium matrices, we form the characteristic polynomial using Faddeev\u2013LeVerrier and call the polynomial solver, then polish. This provides a compact path to <code>eigvals</code> without large dependencies.</p>"},{"location":"paper_guide/","title":"Paper mapping","text":""},{"location":"paper_guide/#mapping-the-paper-to-the-codebase","title":"Mapping the paper to the codebase","text":"<p>This guide cross-references \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d with symbols and modules in this repository.</p> <ul> <li>Geometric polynomial equation and the series solution <code>S[t2,t3,...]</code>:</li> <li>Paper: Equation 0 = 1 \u2212 \u03b1 + t2 \u03b1^2 + t3 \u03b1^3 + ..., with \u03b1 = S[...].</li> <li> <p>Code: <code>geodepoly/hyper_catalan.py</code> implements:</p> <ul> <li><code>hyper_catalan_coefficient(m_counts)</code> for the array coefficients.</li> <li><code>evaluate_hyper_catalan(t_values, max_weight)</code> to numerically sum a truncated S.</li> <li><code>evaluate_quadratic_slice(t2, ...)</code> and <code>catalan_number(n)</code> for the Catalan slice.</li> </ul> </li> <li> <p>Lagrange inversion / series reversion for a shifted polynomial:</p> </li> <li>Paper: Sections on Lagrange inversion and series bootstrap.</li> <li> <p>Code: <code>geodepoly/series_solve.py</code>:</p> <ul> <li><code>shift_expand</code>, <code>inverseseries_g_coeffs</code>, <code>series_step</code>, <code>series_one_root</code>.</li> </ul> </li> <li> <p>Finishing methods and polishing:</p> </li> <li>Paper: Practical computation beyond the formal series.</li> <li> <p>Code: <code>durand_kerner</code>, <code>halley_refine</code>, <code>newton_refine</code>, composed in <code>series_solve_all</code>.</p> </li> <li> <p>Resummation and acceleration:</p> </li> <li>Paper: discusses summation/acceleration themes.</li> <li> <p>Code: <code>geodepoly/resummation.py</code> supports Pad\u00e9 and Borel(-Pad\u00e9) options.</p> </li> <li> <p>The Geode array and combinatorial structure:</p> </li> <li>Paper: factorization and conjectures about the array.</li> <li> <p>Code: <code>hyper_catalan_coefficient</code> and <code>evaluate_hyper_catalan</code> expose the array numerics; future work can add factorization utilities once conjectures are finalized.</p> </li> <li> <p>Bridges and examples:</p> </li> <li>Paper: Worked examples (e.g., Wallis cubic) and CAS bridges.</li> <li>Code: <code>bridges/geodepoly_cli.py</code>, <code>examples/quickstart.py</code>, and tests in <code>tests/</code>.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#residuals-arent-small-enough","title":"Residuals aren\u2019t small enough","text":"<ul> <li>Increase <code>refine_steps</code> (Halley polish) or switch finisher (<code>aberth</code>/<code>dk</code>).</li> <li>Use <code>resum=\"auto\"</code> for series seeds if |t| is near 1.</li> <li>Beware nearly-multiple roots: reduce tolerance or try different centers.</li> </ul>"},{"location":"troubleshooting/#divergence-or-nans","title":"Divergence or NaNs","text":"<ul> <li>Ensure coefficients are finite and leading coefficient is nonzero.</li> <li>Try <code>method=\"dk\"</code> (derivative-free) for pathological cases.</li> </ul>"},{"location":"troubleshooting/#sympy-import-errors","title":"SymPy import errors","text":"<ul> <li>Install: <code>pip install sympy</code> and retry <code>sympy_solve</code> examples.</li> </ul>"},{"location":"troubleshooting/#performance","title":"Performance","text":"<ul> <li>Reduce degree/trials in benchmarks; set <code>boots</code> lower; use <code>numpy</code> method for a baseline.</li> </ul>"}]}