{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geodepoly Docs","text":"<ul> <li>API: <code>solve_poly</code>, <code>solve_all</code>, <code>solve_one</code></li> <li>Methods: <code>hybrid</code>, <code>aberth</code>, <code>dk</code>, <code>numpy</code></li> <li>Resummation: <code>None</code>, <code>pade</code>, <code>borel</code>, <code>borel-pade</code></li> <li>CAS: SymPy plugin, JSON CLI for Mathematica/Maple</li> </ul> <p>See the README for quickstart and <code>paper/GeodePoly_MVP.md</code> for a draft paper.</p>"},{"location":"#theory-and-paper-mapping","title":"Theory and Paper Mapping","text":"<ul> <li>See <code>docs/paper_guide.md</code> for how the paper \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d maps to the implementation.</li> <li>The module <code>geodepoly.hyper_catalan</code> provides utilities for the multivariate series <code>S[t2,t3,...]</code> described in the paper.</li> </ul>"},{"location":"#benchmarks-plots","title":"Benchmarks &amp; Plots","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"#cas-examples","title":"CAS Examples","text":"<ul> <li>SymPy comparison: <code>python examples/sympy_vs_nroots.py</code></li> <li>JSON bridge round-trip: <code>python examples/json_bridge_roundtrip.py</code></li> <li>Mathematica: <code>RunProcess[{\"geodepoly-bridge\"}, \"StandardInput\"-&gt;payloadJSON]</code></li> <li>Maple: <code>ssystem(\"geodepoly-bridge\", payloadJSON)</code></li> </ul> <p>Schema (v1):</p> <pre><code>{\n  \"schemaVersion\": 1,\n  \"coeffs\": [ -6, 11, -6, 1 ],\n  \"kwargs\": { \"method\": \"hybrid\", \"resum\": \"auto\" }\n}\n</code></pre>"},{"location":"#cli-solver","title":"CLI Solver","text":"<ul> <li>Solve from terminal:</li> <li><code>geodepoly-solve --coeffs \"[-6,11,-6,1]\" --method hybrid --resum auto --json</code></li> <li>Or file I/O (schema v1): <code>geodepoly-solve --input payload.json --output roots.json</code></li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#core-solvers","title":"Core solvers","text":"<ul> <li><code>geodepoly.solve_all(coeffs: List[complex], method: str = \"hybrid\", max_order: int = 24, boots: int = 2, tol: float = 1e-12, resum: Optional[str] = None, refine_steps: int = 3, verbose: bool = False) -&gt; List[complex]</code></li> <li>Methods: <code>\"hybrid\" | \"aberth\" | \"dk\" | \"numpy\" | \"batched\"</code></li> <li>Resummation: <code>None | \"pade\" | \"borel\" | \"borel-pade\" | \"auto\"</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import solve_all\ncoeffs = [1, 0, -7, 6]  # 1 - 7 x^2 + 6 x^3 = 0 (low-&gt;high)\nroots = solve_all(coeffs, method=\"hybrid\", resum=\"auto\")\n</code></pre> <ul> <li> <p><code>geodepoly.solve_one(coeffs: List[complex], center: complex|None=None, max_order: int=24, boots: int=3, tol: float=1e-14, resum: Optional[str]=None, refine_steps: int=2) -&gt; complex</code></p> </li> <li> <p><code>geodepoly.solve_poly = solve_all</code> (convenience alias)</p> </li> </ul>"},{"location":"api/#series-reversion-paper-aligned","title":"Series reversion (paper-aligned)","text":"<ul> <li><code>geodepoly.series_solve_all(coeffs, max_order=24, boots=3, tol=1e-12, max_deflation=None, verbose=False) -&gt; List[complex]</code></li> <li><code>geodepoly.series_one_root(coeffs, center=None, max_order=24, boots=3, tol=1e-14) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import series_one_root\ncoeffs = [1, -1.2, 0.3, 1.0]\nroot = series_one_root(coeffs, center=0.0, max_order=24, boots=2)\n</code></pre>"},{"location":"api/#sympy-integration","title":"SymPy integration","text":"<ul> <li><code>geodepoly.sympy_plugin.sympy_solve(poly, return_: str = \"numeric\", **kwargs) -&gt; List</code></li> <li><code>poly</code>: <code>sympy.Expr</code> or <code>sympy.Poly</code></li> <li><code>return_</code>: <code>\"numeric\"</code> (Python complex) or <code>\"expr\"</code> (SymPy numbers)</li> </ul> <p>Example</p> <pre><code>import sympy as sp\nfrom geodepoly.sympy_plugin import sympy_solve\n\nx = sp.symbols('x')\nroots = sympy_solve(x**5 + x - 1, method=\"hybrid\", resum=\"auto\", return_=\"numeric\")\n</code></pre>"},{"location":"api/#eigenvalues","title":"Eigenvalues","text":""},{"location":"api/#data-types-numeric-wrappers","title":"Data types &amp; numeric wrappers","text":"<ul> <li><code>geodepoly.Polynomial([...])</code> \u2014 dense univariate polynomial (low\u2192high) with ops: add/sub/mul/divmod/pow, eval, <code>shift_x</code>, <code>scale_x</code>, <code>differentiate</code>, <code>integrate</code>.</li> </ul> <p>Example</p> <pre><code>from geodepoly import Polynomial\np = Polynomial([1, 0, 1])  # 1 + x^2\nq = p.shift_x(1)           # 2 + 2x + x^2\n</code></pre> <ul> <li>Numeric wrappers: <code>geodepoly.newton_solve</code>, <code>geodepoly.aberth_solve</code>, <code>geodepoly.dk_solve</code>, <code>geodepoly.companion_roots</code>.</li> </ul> <p>Example</p> <pre><code>from geodepoly import newton_solve, companion_roots\nx = newton_solve([-2,0,1], x0=1.0)  # sqrt(2)\nw = companion_roots([-6,11,-6,1])   # [1,2,3]\n</code></pre>"},{"location":"api/#formal-series-scaffold","title":"Formal series scaffold","text":"<ul> <li><code>geodepoly.FormalSeries</code> \u2014 minimal formal series with <code>+</code>, <code>*</code>, <code>truncate_total_degree</code>, <code>compose_univariate</code> (univariate), and <code>to_sympy</code>.</li> <li> <p><code>geodepoly.series_root</code> / <code>geodepoly.series_bootstrap</code> \u2014 scaffolds for soft polynomial formula and shift\u2013solve\u2013add.</p> </li> <li> <p><code>geodepoly.eigs.solve_eigs(A) -&gt; List[complex]</code></p> </li> <li>Forms characteristic polynomial via Faddeev\u2013LeVerrier and calls <code>solve_all</code>.</li> </ul> <p>Example</p> <pre><code>import numpy as np\nfrom geodepoly.eigs import solve_eigs\n\nA = np.array([[0,1],[ -6, 7 ]], dtype=complex)\neigvals = solve_eigs(A)\n</code></pre>"},{"location":"api/#hyper-catalan-utilities","title":"Hyper-Catalan utilities","text":"<ul> <li><code>geodepoly.hyper_catalan.hyper_catalan_coefficient(m_counts: Dict[int,int]) -&gt; int</code></li> <li><code>geodepoly.hyper_catalan.evaluate_hyper_catalan(t_values: Dict[int,complex], max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.evaluate_quadratic_slice(t2: complex, max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.catalan_number(n: int) -&gt; int</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import evaluate_hyper_catalan, evaluate_quadratic_slice, catalan_number\n\nt2 = 0.05\nalpha = evaluate_quadratic_slice(t2, max_weight=20)\nc3 = catalan_number(3)\n</code></pre>"},{"location":"api/#resummation-helpers","title":"Resummation helpers","text":"<ul> <li><code>geodepoly.resummation.eval_series_plain(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_auto(g: List[complex], t: complex) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly.resummation import eval_series_plain, eval_series_pade, eval_series_borel_pade, eval_series_auto\ng = [1, 1, 1, 1, 1]  # toy coefficients for demo\nt = 0.9\nvals = dict(plain=eval_series_plain(g,t), pade=eval_series_pade(g,t), borel_pade=eval_series_borel_pade(g,t), auto=eval_series_auto(g,t))\n</code></pre>"},{"location":"api/#cli-bridge-json","title":"CLI bridge (JSON)","text":"<ul> <li><code>bridges/geodepoly_cli.py</code></li> <li>stdin: <code>{ \"coeffs\": [...], \"kwargs\": { ... } }</code></li> <li>stdout: <code>{ \"roots\": [[re, im], ...] }</code></li> </ul> <p>Example</p> <pre><code>python bridges/geodepoly_cli.py &lt;&lt;'JSON'\n{\"coeffs\":[-6,11,-6,1],\"kwargs\":{\"method\":\"hybrid\",\"resum\":\"auto\"}}\nJSON\n</code></pre>"},{"location":"batched/","title":"Batched kernels (MVP3)","text":"<ul> <li>Backends: NumPy (reference), Torch, JAX.</li> <li>Ops:</li> <li><code>batched_poly_eval(coeffs, xs, backend)</code></li> <li><code>batched_newton_step(coeffs, xs, backend)</code></li> <li><code>torch_root_layer(steps, tol)</code> differentiable Newton layer</li> <li><code>batched_solve_all(coeffs_batch, backend, steps)</code> (one root per polynomial)</li> </ul>"},{"location":"batched/#integrating-with-the-main-solver","title":"Integrating with the main solver","text":"<ul> <li>Use <code>method=\"batched\"</code> to solve a single polynomial via a vectorized Newton + deflation baseline (CPU/NumPy path today):</li> </ul> <pre><code>from geodepoly import solve_all\nroots = solve_all([ -6, 11, -6, 1 ], method=\"batched\")\n</code></pre> <p>Bench (preview): expect 10\u2013100\u00d7 throughput vs pure Python on large batches (Torch/JAX on GPU).</p> <p>Quick bench:</p> <pre><code>python scripts/bench_batched.py --backend numpy --batch 8192 --degree 16\n# if GPU available\npython scripts/bench_batched.py --backend torch --batch 65536 --degree 16\n</code></pre>"},{"location":"bench_presets/","title":"Bench presets","text":"<p>Use <code>scripts/bench_presets.py</code> to generate the standard CSVs and plots:</p> <pre><code>python scripts/bench_presets.py quick\n</code></pre> <p>Outputs: - <code>docs/assets/bench.csv</code>, <code>bench_agg.csv</code>, plots under <code>docs/assets/</code> - <code>docs/assets/newton_vs_hybrid_tuned.csv</code> - <code>docs/assets/edge_cases.csv</code></p>"},{"location":"benchmarks/","title":"Benchmarks","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"benchmarks/#newton-vs-hybrid-tuned","title":"Newton vs hybrid (tuned)","text":"<p>Summary (medians over 5 trials):</p> degree method time_median(s) res_median 3 hybrid 0.0027 2.48e-16 3 newton 0.0000 3.33e-16 5 hybrid 0.0060 2.22e-15 5 newton 0.0000 1.89e-15 8 hybrid 0.0142 1.22e-14 8 newton 0.0001 8.30e-15 12 hybrid 0.0314 6.17e-13 12 newton 0.0003 6.17e-13 16 hybrid 0.0796 5.60e-11 16 newton 0.0017 2.70e-11 20 hybrid 0.1191 1.91e-10 20 newton 0.0027 3.19e-10 <p>CSV: <code>docs/assets/newton_vs_hybrid_tuned.csv</code></p>"},{"location":"benchmarks/#edge-cases-iteration-profile","title":"Edge cases: iteration profile","text":"<p>We measure time, residual, and (for Newton) total iteration count on a few tougher instances (clusters, ill\u2011scaled, |t|\u22481). Hybrid and Aberth reach the target with minimal polish; Newton iteration counts can spike.</p> case hybrid time(s) aberth time(s) newton time(s) newton iters residual (\u2248) double_root 0.0041 0.0005 0.0001 87 1e-16\u20131e-23 cluster_eps_1e-12 0.0038 0.0005 0.0001 96 1e-38\u20131e-25 cluster_eps_1e-10 0.0038 0.0005 0.0001 96 1e-39\u20131e-25 cluster_eps_1e-08 0.0035 0.0005 0.0001 95 1e-16\u20131e-48 cluster_eps_1e-06 0.0034 0.0005 0.0001 81 1e-41\u20131e-60 cluster_eps_1e-4 0.0030 0.0006 0.0001 63 1e-16\u20131e-60 ill_scaled 0.0036 0.0007 0.0001 68 1e-14 rotated_cluster 0.0071 0.0012 0.0002 320 1e-16 near_t_one 0.0032 0.0009 0.0001 72 1e-16 <p>CSV: <code>docs/assets/edge_cases.csv</code></p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#solve-all-roots-hybrid","title":"Solve all roots (hybrid)","text":"<pre><code>from geodepoly import solve_all\ncoeffs = [1, 0, -7, 6]\nroots = solve_all(coeffs, method=\"hybrid\", resum=\"auto\")\n</code></pre>"},{"location":"examples/#series-one-root","title":"Series one root","text":"<pre><code>from geodepoly import series_one_root\ncoeffs = [1, -1.2, 0.3, 1.0]\nroot = series_one_root(coeffs, center=0.0, max_order=24, boots=2)\n</code></pre>"},{"location":"examples/#sympy-integration","title":"SymPy integration","text":"<pre><code>import sympy as sp\nfrom geodepoly.sympy_plugin import sympy_solve\nx = sp.symbols('x')\nroots = sympy_solve(x**5 + x - 1, method=\"hybrid\", resum=\"auto\", return_=\"numeric\")\n</code></pre>"},{"location":"examples/#eigenvalues","title":"Eigenvalues","text":"<pre><code>import numpy as np\nfrom geodepoly.eigs import solve_eigs\nA = np.array([[0,1],[-6,7]], dtype=complex)\nvals = solve_eigs(A)\n</code></pre>"},{"location":"examples/#json-bridge","title":"JSON bridge","text":"<pre><code>python bridges/geodepoly_cli.py &lt;&lt;'JSON'\n{\"coeffs\":[-6,11,-6,1],\"kwargs\":{\"method\":\"hybrid\",\"resum\":\"auto\"}}\nJSON\n</code></pre>"},{"location":"examples/#geode-arrays","title":"Geode arrays","text":"<pre><code>python examples/geode_arrays_demo.py\n</code></pre>"},{"location":"examples/#eisensteinbring-quintic","title":"Eisenstein/Bring quintic","text":"<pre><code>python examples/eisenstein_quintic_demo.py\n</code></pre>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#what-coefficient-order-do-functions-expect","title":"What coefficient order do functions expect?","text":"<p>Low-to-high (a0, a1, ..., aN) for polynomial a0 + a1 x + ... + aN x^N = 0.</p>"},{"location":"faq/#how-do-i-choose-a-method","title":"How do I choose a method?","text":"<ul> <li><code>hybrid</code> is a good default (series seeds + Aberth finisher).</li> <li><code>aberth</code> for simultaneous refinement.</li> <li><code>dk</code> for robust derivative-free finishing.</li> <li><code>numpy</code> if you prefer companion eigenvalues (requires NumPy).</li> </ul>"},{"location":"faq/#when-should-i-use-resummation","title":"When should I use resummation?","text":"<p>If the local parameter |t| = |-a0/a1| is not small, use <code>resum=\"auto\"</code> (tries Pad\u00e9/Borel\u2013Pad\u00e9).</p>"},{"location":"faq/#what-about-multiple-or-clustered-roots","title":"What about multiple or clustered roots?","text":"<p>They are ill-conditioned. We add adaptive damping in Aberth and multiplicity-aware Halley polish, but residuals may still be sensitive.</p>"},{"location":"faq/#does-sympy-need-to-be-installed","title":"Does SymPy need to be installed?","text":"<p>Only for the <code>sympy_plugin</code>. Core solvers work with Python complex numbers.</p>"},{"location":"faq/#are-eigenvalues-supported","title":"Are eigenvalues supported?","text":"<p>Yes, via <code>solve_eigs(A)</code> (Faddeev\u2013LeVerrier + solver polish).</p>"},{"location":"gallery/","title":"Gallery","text":""},{"location":"gallery/#bench-plots","title":"Bench plots","text":""},{"location":"gallery/#examples","title":"Examples","text":"<ul> <li>Methods comparison: see <code>examples/compare_methods.py</code></li> <li>Resummation effect: see <code>examples/resummation_effect.py</code></li> <li>Eigenvalues demo: see <code>examples/eigs_demo.py</code></li> </ul>"},{"location":"geode_gpu_spec/","title":"Geode GPU Roadmap (draft)","text":""},{"location":"geode_gpu_spec/#goals","title":"Goals","text":"<ul> <li>Batched root solves for many polynomials</li> <li>Stable kernels for Aberth/Halley updates</li> </ul>"},{"location":"geode_gpu_spec/#tiling-layout","title":"Tiling &amp; Layout","text":"<ul> <li>Face-layer tiling aligned with hyper-Catalan layers</li> <li>Structure-of-arrays layout for complex ops</li> </ul>"},{"location":"geode_gpu_spec/#prototype","title":"Prototype","text":"<ul> <li>JAX/NumPy/Torch sketch for vectorized Newton steps</li> </ul>"},{"location":"geode_gpu_spec/#usage","title":"Usage","text":"<pre><code># NumPy (CPU):\npython scripts/bench_gpu_prototype.py --backend numpy --batch 4096 --degree 16 --steps 50\n\n# Torch (GPU if available, else CPU):\npython scripts/bench_gpu_prototype.py --backend torch --batch 4096 --degree 16 --steps 50 --device cuda\n\n# JAX (CPU/GPU depending on install):\npython scripts/bench_gpu_prototype.py --backend jax --batch 4096 --degree 16 --steps 50\n</code></pre> <p>Outputs throughput (steps/sec) and residual sanity check.</p>"},{"location":"geode_gpu_spec/#next-steps","title":"Next steps","text":"<ul> <li>Microbenchmarks and accuracy checks vs CPU</li> <li>Memory-bound vs compute-bound analysis</li> </ul>"},{"location":"geodebench/","title":"GeodeBench v0 (MVP)","text":"<ul> <li>S slice (quadratic): <code>t2</code> only; target <code>alpha</code>.</li> <li>G slice (multivariate): small <code>t2,t3</code> nonzero; target <code>alpha</code>.</li> </ul> <p>Tasks: - Coefficient prediction: recover truncated coefficients from samples. - Geode recovery: predict <code>alpha</code> from slice inputs. - Invariance checks: evaluate symmetry/generalization splits.</p> <p>Generate data:</p> <pre><code>python bench/generate_slices.py --degrees 3,5,8 --trials 10 --out docs/assets/geode_slices.csv\n</code></pre> <p>Starter notebook: <code>notebooks/GeodeBench_Starter.ipynb</code></p> <p>Baseline:</p> <pre><code>python scripts/baseline_transformer.py --in docs/assets/geode_slices.csv\n# Example output: Baseline mean abs error: 4.44e-16\n</code></pre>"},{"location":"geodebench/#leaderboard-v0-preview","title":"Leaderboard (v0 preview)","text":"Method Split Metric Score Linear baseline Random (S+G) MAE( alpha Naive OEIS-style Symmetry holdout MAE( alpha Tiny Transformer (stub) Symmetry holdout MAE( alpha"},{"location":"how_it_works/","title":"How it works (deep-dive)","text":"<p>This section summarizes the core algorithmic choices behind geodepoly and connects them to the paper.</p>"},{"location":"how_it_works/#1-recenter-and-series-seed","title":"1) Recenter and series seed","text":"<p>Given coefficients low-to-high <code>p(x) = a0 + a1 x + ... + aN x^N</code>, choose a center <code>\u03bc</code> and expand <code>q(y) = p(\u03bc + y) = a0 + a1 y + a2 y^2 + ...</code> via binomial shifting. If <code>a1 \u2260 0</code>, set <code>t = -a0/a1</code>.</p> <p>We invert <code>F(y) = y + \u03b22 y^2 + \u03b23 y^3 + ...</code> with <code>\u03b2k = ak/a1</code> using Lagrange inversion to obtain inverse-series coefficients <code>{g_m}</code> for the local root increment <code>y \u2248 \u03a3 g_m t^m</code>.</p>"},{"location":"how_it_works/#2-resummation-and-auto-selection","title":"2) Resummation and auto selection","text":"<p>Truncated series can be fragile near their convergence boundary (|t| ~ 1). We provide: - Plain: direct Horner evaluation of \u03a3 g_m t^m - Pad\u00e9: near-diagonal Pad\u00e9 rational approximation - Borel\u2013Pad\u00e9: Pade of the Borel transform followed by Gauss\u2013Laguerre - Auto: small Pad\u00e9 grid scored for stability, falling back to Borel\u2013Pad\u00e9 or plain</p> <p>Use <code>resum=\"auto\"</code> for robust default behavior.</p>"},{"location":"how_it_works/#3-bootstrap-and-deflation","title":"3) Bootstrap and deflation","text":"<p>A few bootstrap steps update the center <code>\u03bc \u2190 \u03bc + y</code>. When a root is good, synthetic division (deflation) reduces degree. The MVP solves all roots with a robust finisher after obtaining one or two good seeds.</p>"},{"location":"how_it_works/#4-finishers-and-polishing","title":"4) Finishers and polishing","text":"<ul> <li>Aberth\u2013Ehrlich: simultaneous iteration with adaptive damping and minimal repulsion for clustered roots</li> <li>Durand\u2013Kerner: derivative-free simultaneous method</li> <li>Halley polishing: applied per root; we also provide multiplicity-aware Halley when a root appears repeated</li> </ul>"},{"location":"how_it_works/#5-multipleclustered-roots","title":"5) Multiple/clustered roots","text":"<p>We estimate local multiplicity using <code>m\u0302 \u2248 Re( p * p'' / p'^2 )</code> and apply a multiplicity-aware Halley update when <code>m\u0302 \u2265 2</code>. Clustered roots benefit from Aberth damping and repulsion.</p>"},{"location":"how_it_works/#6-hyper-catalan-connection","title":"6) Hyper-Catalan connection","text":"<p>The generating series <code>S[t2,t3,...]</code> with hyper-Catalan coefficients solves a canonical geometric polynomial and motivates the series-reversion view. We expose utilities to evaluate slices of <code>S</code> and to compute coefficients for exploration and benchmarks.</p>"},{"location":"how_it_works/#7-eigenvalues-via-characteristic-polynomial","title":"7) Eigenvalues via characteristic polynomial","text":"<p>For small/medium matrices, we form the characteristic polynomial using Faddeev\u2013LeVerrier and call the polynomial solver, then polish. This provides a compact path to <code>eigvals</code> without large dependencies.</p>"},{"location":"paper_guide/","title":"Paper mapping","text":""},{"location":"paper_guide/#mapping-the-paper-to-the-codebase","title":"Mapping the paper to the codebase","text":"<p>This guide cross-references \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d with symbols and modules in this repository.</p> <ul> <li>Geometric polynomial equation and the series solution <code>S[t2,t3,...]</code>:</li> <li>Paper: Equation 0 = 1 \u2212 \u03b1 + t2 \u03b1^2 + t3 \u03b1^3 + ..., with \u03b1 = S[...].</li> <li> <p>Code: <code>geodepoly/hyper_catalan.py</code> implements:</p> <ul> <li><code>hyper_catalan_coefficient(m_counts)</code> for the array coefficients.</li> <li><code>evaluate_hyper_catalan(t_values, max_weight)</code> to numerically sum a truncated S.</li> <li><code>evaluate_quadratic_slice(t2, ...)</code> and <code>catalan_number(n)</code> for the Catalan slice.</li> </ul> </li> <li> <p>Lagrange inversion / series reversion for a shifted polynomial:</p> </li> <li>Paper: Sections on Lagrange inversion and series bootstrap.</li> <li> <p>Code: <code>geodepoly/series_solve.py</code>:</p> <ul> <li><code>shift_expand</code>, <code>inverseseries_g_coeffs</code>, <code>series_step</code>, <code>series_one_root</code>.</li> </ul> </li> <li> <p>Finishing methods and polishing:</p> </li> <li>Paper: Practical computation beyond the formal series.</li> <li> <p>Code: <code>durand_kerner</code>, <code>halley_refine</code>, <code>newton_refine</code>, composed in <code>series_solve_all</code>.</p> </li> <li> <p>Resummation and acceleration:</p> </li> <li>Paper: discusses summation/acceleration themes.</li> <li> <p>Code: <code>geodepoly/resummation.py</code> supports Pad\u00e9 and Borel(-Pad\u00e9) options.</p> </li> <li> <p>The Geode array and combinatorial structure:</p> </li> <li>Paper: factorization and conjectures about the array.</li> <li> <p>Code: <code>hyper_catalan_coefficient</code> and <code>evaluate_hyper_catalan</code> expose the array numerics; future work can add factorization utilities once conjectures are finalized.</p> </li> <li> <p>Bridges and examples:</p> </li> <li>Paper: Worked examples (e.g., Wallis cubic) and CAS bridges.</li> <li>Code: <code>bridges/geodepoly_cli.py</code>, <code>examples/quickstart.py</code>, and tests in <code>tests/</code>.</li> </ul>"},{"location":"performance/","title":"Performance Notes","text":""},{"location":"performance/#numba-acceleration-opt-in","title":"Numba acceleration (opt-in)","text":"<p>Enable JIT for core polynomial evaluation by setting an environment variable before import:</p> <pre><code>export GEODEPOLY_USE_NUMBA=1\npython -c \"from geodepoly.util import poly_eval; print(poly_eval([1,0,-7,6], 2.0))\"\n</code></pre> <p>Notes: - Speeds up <code>poly_eval</code> and <code>poly_eval_dp_ddp</code> (used inside finishers like Aberth/Polish). - Falls back to pure Python if Numba is not installed.</p> <p>Solver usage with Numba on:</p> <pre><code>export GEODEPOLY_USE_NUMBA=1\npython -c \"from geodepoly import solve_all; print(solve_all([-6,11,-6,1]))\"\n</code></pre>"},{"location":"performance/#batched-and-gpu","title":"Batched and GPU","text":"<ul> <li>See <code>docs/batched.md</code> and <code>scripts/bench_gpu_prototype.py</code> for vectorized Newton steps.</li> <li>Torch/JAX backends can leverage GPU if available for batched kernels.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#residuals-arent-small-enough","title":"Residuals aren\u2019t small enough","text":"<ul> <li>Increase <code>refine_steps</code> (Halley polish) or switch finisher (<code>aberth</code>/<code>dk</code>).</li> <li>Use <code>resum=\"auto\"</code> for series seeds if |t| is near 1.</li> <li>Beware nearly-multiple roots: reduce tolerance or try different centers.</li> </ul>"},{"location":"troubleshooting/#divergence-or-nans","title":"Divergence or NaNs","text":"<ul> <li>Ensure coefficients are finite and leading coefficient is nonzero.</li> <li>Try <code>method=\"dk\"</code> (derivative-free) for pathological cases.</li> </ul>"},{"location":"troubleshooting/#sympy-import-errors","title":"SymPy import errors","text":"<ul> <li>Install: <code>pip install sympy</code> and retry <code>sympy_solve</code> examples.</li> </ul>"},{"location":"troubleshooting/#performance","title":"Performance","text":"<ul> <li>Reduce degree/trials in benchmarks; set <code>boots</code> lower; use <code>numpy</code> method for a baseline.</li> </ul>"}]}