{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geodepoly Docs","text":"<ul> <li>API: <code>solve_poly</code>, <code>solve_all</code>, <code>solve_one</code></li> <li>Methods: <code>hybrid</code>, <code>aberth</code>, <code>dk</code>, <code>numpy</code></li> <li>Resummation: <code>None</code>, <code>pade</code>, <code>borel</code>, <code>borel-pade</code></li> <li>CAS: SymPy plugin, JSON CLI for Mathematica/Maple</li> </ul> <p>See the README for quickstart and <code>paper/GeodePoly_MVP.md</code> for a draft paper.</p>"},{"location":"#theory-and-paper-mapping","title":"Theory and Paper Mapping","text":"<ul> <li>See <code>docs/paper_guide.md</code> for how the paper \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d maps to the implementation.</li> <li>The module <code>geodepoly.hyper_catalan</code> provides utilities for the multivariate series <code>S[t2,t3,...]</code> described in the paper.</li> </ul>"},{"location":"#benchmarks-plots","title":"Benchmarks &amp; Plots","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"#cas-examples","title":"CAS Examples","text":"<ul> <li>SymPy comparison: <code>python examples/sympy_vs_nroots.py</code></li> <li>JSON bridge round-trip: <code>python examples/json_bridge_roundtrip.py</code></li> <li>Mathematica: <code>RunProcess[{\"python\",\"bridges/geodepoly_cli.py\"}, \"StandardInput\"-&gt;payloadJSON]</code></li> <li>Maple: <code>ssystem(\"python bridges/geodepoly_cli.py\", payloadJSON)</code></li> </ul>"},{"location":"benchmarks/","title":"Benchmarks","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"geode_gpu_spec/","title":"Geode GPU Roadmap (draft)","text":""},{"location":"geode_gpu_spec/#goals","title":"Goals","text":"<ul> <li>Batched root solves for many polynomials</li> <li>Stable kernels for Aberth/Halley updates</li> </ul>"},{"location":"geode_gpu_spec/#tiling-layout","title":"Tiling &amp; Layout","text":"<ul> <li>Face-layer tiling aligned with hyper-Catalan layers</li> <li>Structure-of-arrays layout for complex ops</li> </ul>"},{"location":"geode_gpu_spec/#prototype","title":"Prototype","text":"<ul> <li>JAX/NumPy sketch for vectorized series seeds and Aberth steps</li> </ul>"},{"location":"geode_gpu_spec/#next-steps","title":"Next steps","text":"<ul> <li>Microbenchmarks and accuracy checks vs CPU</li> <li>Memory-bound vs compute-bound analysis</li> </ul>"},{"location":"paper_guide/","title":"Paper mapping","text":""},{"location":"paper_guide/#mapping-the-paper-to-the-codebase","title":"Mapping the paper to the codebase","text":"<p>This guide cross-references \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d with symbols and modules in this repository.</p> <ul> <li>Geometric polynomial equation and the series solution <code>S[t2,t3,...]</code>:</li> <li>Paper: Equation 0 = 1 \u2212 \u03b1 + t2 \u03b1^2 + t3 \u03b1^3 + ..., with \u03b1 = S[...].</li> <li> <p>Code: <code>geodepoly/hyper_catalan.py</code> implements:</p> <ul> <li><code>hyper_catalan_coefficient(m_counts)</code> for the array coefficients.</li> <li><code>evaluate_hyper_catalan(t_values, max_weight)</code> to numerically sum a truncated S.</li> <li><code>evaluate_quadratic_slice(t2, ...)</code> and <code>catalan_number(n)</code> for the Catalan slice.</li> </ul> </li> <li> <p>Lagrange inversion / series reversion for a shifted polynomial:</p> </li> <li>Paper: Sections on Lagrange inversion and series bootstrap.</li> <li> <p>Code: <code>geodepoly/series_solve.py</code>:</p> <ul> <li><code>shift_expand</code>, <code>inverseseries_g_coeffs</code>, <code>series_step</code>, <code>series_one_root</code>.</li> </ul> </li> <li> <p>Finishing methods and polishing:</p> </li> <li>Paper: Practical computation beyond the formal series.</li> <li> <p>Code: <code>durand_kerner</code>, <code>halley_refine</code>, <code>newton_refine</code>, composed in <code>series_solve_all</code>.</p> </li> <li> <p>Resummation and acceleration:</p> </li> <li>Paper: discusses summation/acceleration themes.</li> <li> <p>Code: <code>geodepoly/resummation.py</code> supports Pad\u00e9 and Borel(-Pad\u00e9) options.</p> </li> <li> <p>The Geode array and combinatorial structure:</p> </li> <li>Paper: factorization and conjectures about the array.</li> <li> <p>Code: <code>hyper_catalan_coefficient</code> and <code>evaluate_hyper_catalan</code> expose the array numerics; future work can add factorization utilities once conjectures are finalized.</p> </li> <li> <p>Bridges and examples:</p> </li> <li>Paper: Worked examples (e.g., Wallis cubic) and CAS bridges.</li> <li>Code: <code>bridges/geodepoly_cli.py</code>, <code>examples/quickstart.py</code>, and tests in <code>tests/</code>.</li> </ul>"}]}