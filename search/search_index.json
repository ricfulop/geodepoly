{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"geodepoly Docs","text":"<ul> <li>API: <code>solve_poly</code>, <code>solve_all</code>, <code>solve_one</code></li> <li>Methods: <code>hybrid</code>, <code>aberth</code>, <code>dk</code>, <code>numpy</code></li> <li>Resummation: <code>None</code>, <code>pade</code>, <code>borel</code>, <code>borel-pade</code></li> <li>CAS: SymPy plugin, JSON CLI for Mathematica/Maple</li> </ul> <p>See the README for quickstart and <code>paper/GeodePoly_MVP.md</code> for a draft paper.</p>"},{"location":"#theory-and-paper-mapping","title":"Theory and Paper Mapping","text":"<ul> <li>See <code>docs/paper_guide.md</code> for how the paper \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d maps to the implementation.</li> <li>The module <code>geodepoly.hyper_catalan</code> provides utilities for the multivariate series <code>S[t2,t3,...]</code> described in the paper.</li> </ul>"},{"location":"#benchmarks-plots","title":"Benchmarks &amp; Plots","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"#cas-examples","title":"CAS Examples","text":"<ul> <li>SymPy comparison: <code>python examples/sympy_vs_nroots.py</code></li> <li>JSON bridge round-trip: <code>python examples/json_bridge_roundtrip.py</code></li> <li>Mathematica: <code>RunProcess[{\"python\",\"bridges/geodepoly_cli.py\"}, \"StandardInput\"-&gt;payloadJSON]</code></li> <li>Maple: <code>ssystem(\"python bridges/geodepoly_cli.py\", payloadJSON)</code></li> </ul>"},{"location":"api/","title":"API","text":""},{"location":"api/#core-solvers","title":"Core solvers","text":"<ul> <li><code>geodepoly.solve_all(coeffs: List[complex], method: str = \"hybrid\", max_order: int = 24, boots: int = 2, tol: float = 1e-12, resum: Optional[str] = None, refine_steps: int = 3, verbose: bool = False) -&gt; List[complex]</code></li> <li>Methods: <code>\"hybrid\" | \"aberth\" | \"dk\" | \"numpy\"</code></li> <li>Resummation: <code>None | \"pade\" | \"borel\" | \"borel-pade\" | \"auto\"</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import solve_all\ncoeffs = [1, 0, -7, 6]  # 1 - 7 x^2 + 6 x^3 = 0 (low-&gt;high)\nroots = solve_all(coeffs, method=\"hybrid\", resum=\"auto\")\n</code></pre> <ul> <li> <p><code>geodepoly.solve_one(coeffs: List[complex], center: complex|None=None, max_order: int=24, boots: int=3, tol: float=1e-14, resum: Optional[str]=None, refine_steps: int=2) -&gt; complex</code></p> </li> <li> <p><code>geodepoly.solve_poly = solve_all</code> (convenience alias)</p> </li> </ul>"},{"location":"api/#series-reversion-paper-aligned","title":"Series reversion (paper-aligned)","text":"<ul> <li><code>geodepoly.series_solve_all(coeffs, max_order=24, boots=3, tol=1e-12, max_deflation=None, verbose=False) -&gt; List[complex]</code></li> <li><code>geodepoly.series_one_root(coeffs, center=None, max_order=24, boots=3, tol=1e-14) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import series_one_root\ncoeffs = [1, -1.2, 0.3, 1.0]\nroot = series_one_root(coeffs, center=0.0, max_order=24, boots=2)\n</code></pre>"},{"location":"api/#sympy-integration","title":"SymPy integration","text":"<ul> <li><code>geodepoly.sympy_plugin.sympy_solve(poly, return_: str = \"numeric\", **kwargs) -&gt; List</code></li> <li><code>poly</code>: <code>sympy.Expr</code> or <code>sympy.Poly</code></li> <li><code>return_</code>: <code>\"numeric\"</code> (Python complex) or <code>\"expr\"</code> (SymPy numbers)</li> </ul> <p>Example</p> <pre><code>import sympy as sp\nfrom geodepoly.sympy_plugin import sympy_solve\n\nx = sp.symbols('x')\nroots = sympy_solve(x**5 + x - 1, method=\"hybrid\", resum=\"auto\", return_=\"numeric\")\n</code></pre>"},{"location":"api/#eigenvalues","title":"Eigenvalues","text":"<ul> <li><code>geodepoly.eigs.solve_eigs(A) -&gt; List[complex]</code></li> <li>Forms characteristic polynomial via Faddeev\u2013LeVerrier and calls <code>solve_all</code>.</li> </ul> <p>Example</p> <pre><code>import numpy as np\nfrom geodepoly.eigs import solve_eigs\n\nA = np.array([[0,1],[ -6, 7 ]], dtype=complex)\neigvals = solve_eigs(A)\n</code></pre>"},{"location":"api/#hyper-catalan-utilities","title":"Hyper-Catalan utilities","text":"<ul> <li><code>geodepoly.hyper_catalan.hyper_catalan_coefficient(m_counts: Dict[int,int]) -&gt; int</code></li> <li><code>geodepoly.hyper_catalan.evaluate_hyper_catalan(t_values: Dict[int,complex], max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.evaluate_quadratic_slice(t2: complex, max_weight: int) -&gt; complex</code></li> <li><code>geodepoly.hyper_catalan.catalan_number(n: int) -&gt; int</code></li> </ul> <p>Example</p> <pre><code>from geodepoly import evaluate_hyper_catalan, evaluate_quadratic_slice, catalan_number\n\nt2 = 0.05\nalpha = evaluate_quadratic_slice(t2, max_weight=20)\nc3 = catalan_number(3)\n</code></pre>"},{"location":"api/#resummation-helpers","title":"Resummation helpers","text":"<ul> <li><code>geodepoly.resummation.eval_series_plain(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_borel_pade(g: List[complex], t: complex) -&gt; complex</code></li> <li><code>geodepoly.resummation.eval_series_auto(g: List[complex], t: complex) -&gt; complex</code></li> </ul> <p>Example</p> <pre><code>from geodepoly.resummation import eval_series_plain, eval_series_pade, eval_series_borel_pade, eval_series_auto\ng = [1, 1, 1, 1, 1]  # toy coefficients for demo\nt = 0.9\nvals = dict(plain=eval_series_plain(g,t), pade=eval_series_pade(g,t), borel_pade=eval_series_borel_pade(g,t), auto=eval_series_auto(g,t))\n</code></pre>"},{"location":"api/#cli-bridge-json","title":"CLI bridge (JSON)","text":"<ul> <li><code>bridges/geodepoly_cli.py</code></li> <li>stdin: <code>{ \"coeffs\": [...], \"kwargs\": { ... } }</code></li> <li>stdout: <code>{ \"roots\": [[re, im], ...] }</code></li> </ul> <p>Example</p> <pre><code>python bridges/geodepoly_cli.py &lt;&lt;'JSON'\n{\"coeffs\":[-6,11,-6,1],\"kwargs\":{\"method\":\"hybrid\",\"resum\":\"auto\"}}\nJSON\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<ul> <li>Run: <code>python scripts/bench_compare.py --degrees 3,5,8,12 --methods hybrid,aberth,dk --trials 10 --out docs/assets/bench.csv --agg_out docs/assets/bench_agg.csv</code></li> <li>Plot: <code>python scripts/plot_bench.py --in docs/assets/bench_agg.csv --out docs/assets</code></li> </ul>"},{"location":"geode_gpu_spec/","title":"Geode GPU Roadmap (draft)","text":""},{"location":"geode_gpu_spec/#goals","title":"Goals","text":"<ul> <li>Batched root solves for many polynomials</li> <li>Stable kernels for Aberth/Halley updates</li> </ul>"},{"location":"geode_gpu_spec/#tiling-layout","title":"Tiling &amp; Layout","text":"<ul> <li>Face-layer tiling aligned with hyper-Catalan layers</li> <li>Structure-of-arrays layout for complex ops</li> </ul>"},{"location":"geode_gpu_spec/#prototype","title":"Prototype","text":"<ul> <li>JAX/NumPy sketch for vectorized series seeds and Aberth steps</li> </ul>"},{"location":"geode_gpu_spec/#next-steps","title":"Next steps","text":"<ul> <li>Microbenchmarks and accuracy checks vs CPU</li> <li>Memory-bound vs compute-bound analysis</li> </ul>"},{"location":"paper_guide/","title":"Paper mapping","text":""},{"location":"paper_guide/#mapping-the-paper-to-the-codebase","title":"Mapping the paper to the codebase","text":"<p>This guide cross-references \u201cA Hyper-Catalan Series Solution to Polynomial Equations, and the Geode\u201d with symbols and modules in this repository.</p> <ul> <li>Geometric polynomial equation and the series solution <code>S[t2,t3,...]</code>:</li> <li>Paper: Equation 0 = 1 \u2212 \u03b1 + t2 \u03b1^2 + t3 \u03b1^3 + ..., with \u03b1 = S[...].</li> <li> <p>Code: <code>geodepoly/hyper_catalan.py</code> implements:</p> <ul> <li><code>hyper_catalan_coefficient(m_counts)</code> for the array coefficients.</li> <li><code>evaluate_hyper_catalan(t_values, max_weight)</code> to numerically sum a truncated S.</li> <li><code>evaluate_quadratic_slice(t2, ...)</code> and <code>catalan_number(n)</code> for the Catalan slice.</li> </ul> </li> <li> <p>Lagrange inversion / series reversion for a shifted polynomial:</p> </li> <li>Paper: Sections on Lagrange inversion and series bootstrap.</li> <li> <p>Code: <code>geodepoly/series_solve.py</code>:</p> <ul> <li><code>shift_expand</code>, <code>inverseseries_g_coeffs</code>, <code>series_step</code>, <code>series_one_root</code>.</li> </ul> </li> <li> <p>Finishing methods and polishing:</p> </li> <li>Paper: Practical computation beyond the formal series.</li> <li> <p>Code: <code>durand_kerner</code>, <code>halley_refine</code>, <code>newton_refine</code>, composed in <code>series_solve_all</code>.</p> </li> <li> <p>Resummation and acceleration:</p> </li> <li>Paper: discusses summation/acceleration themes.</li> <li> <p>Code: <code>geodepoly/resummation.py</code> supports Pad\u00e9 and Borel(-Pad\u00e9) options.</p> </li> <li> <p>The Geode array and combinatorial structure:</p> </li> <li>Paper: factorization and conjectures about the array.</li> <li> <p>Code: <code>hyper_catalan_coefficient</code> and <code>evaluate_hyper_catalan</code> expose the array numerics; future work can add factorization utilities once conjectures are finalized.</p> </li> <li> <p>Bridges and examples:</p> </li> <li>Paper: Worked examples (e.g., Wallis cubic) and CAS bridges.</li> <li>Code: <code>bridges/geodepoly_cli.py</code>, <code>examples/quickstart.py</code>, and tests in <code>tests/</code>.</li> </ul>"}]}